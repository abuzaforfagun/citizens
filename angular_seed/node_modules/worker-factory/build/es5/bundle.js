(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('compilerr'), require('babel-runtime/regenerator'), require('tslib'), require('fast-unique-numbers')) :
    typeof define === 'function' && define.amd ? define(['exports', 'compilerr', 'babel-runtime/regenerator', 'tslib', 'fast-unique-numbers'], factory) :
    (factory((global.workerFactory = {}),global.compilerr,global._regeneratorRuntime,global.tslib_1,global.fastUniqueNumbers));
}(this, (function (exports,compilerr,_regeneratorRuntime,tslib_1,fastUniqueNumbers) { 'use strict';

    _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;

    var JSON_RPC_ERROR_CODES = { INTERNAL_ERROR: -32603, INVALID_PARAMS: -32602, METHOD_NOT_FOUND: -32601 };
    var renderMethodNotFoundError = compilerr.compile({
        message: 'The requested method called "${method}" is not supported.',
        status: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND
    });
    var renderMissingResponseError = compilerr.compile({
        message: 'The handler of the method called "${method}" returned no required result.',
        status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    var renderUnexpectedResultError = compilerr.compile({
        message: 'The handler of the method called "${method}" returned an unexpected result.',
        status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    var renderUnknownPortIdError = compilerr.compile({
        message: 'The specified parameter called "portId" with the given value "${portId}" does not identify a port connected to this worker.',
        status: JSON_RPC_ERROR_CODES.INVALID_PARAMS
    });

    var _this = undefined;
    var createMessageHandler = function createMessageHandler(receiver, workerImplementation, isSupportingTransferables) {
        return function (_ref) {
            var _ref$data = _ref.data,
                id = _ref$data.id,
                method = _ref$data.method,
                params = _ref$data.params;
            return tslib_1.__awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
                var messageHandler, response, synchronousResponse, result, _synchronousResponse$, transferables, message, _err$status, status;

                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                messageHandler = workerImplementation[method];
                                _context.prev = 1;

                                if (!(messageHandler === undefined)) {
                                    _context.next = 4;
                                    break;
                                }

                                throw renderMethodNotFoundError({ method: method });

                            case 4:
                                response = messageHandler(params);

                                if (!(response === undefined)) {
                                    _context.next = 7;
                                    break;
                                }

                                throw renderMissingResponseError({ method: method });

                            case 7:
                                if (!(response instanceof Promise)) {
                                    _context.next = 13;
                                    break;
                                }

                                _context.next = 10;
                                return response;

                            case 10:
                                _context.t0 = _context.sent;
                                _context.next = 14;
                                break;

                            case 13:
                                _context.t0 = response;

                            case 14:
                                synchronousResponse = _context.t0;

                                if (!(id === null)) {
                                    _context.next = 20;
                                    break;
                                }

                                if (!(synchronousResponse.result !== undefined)) {
                                    _context.next = 18;
                                    break;
                                }

                                throw renderUnexpectedResultError({ method: method });

                            case 18:
                                _context.next = 34;
                                break;

                            case 20:
                                if (!(synchronousResponse.result === undefined)) {
                                    _context.next = 22;
                                    break;
                                }

                                throw renderUnexpectedResultError({ method: method });

                            case 22:
                                result = synchronousResponse.result, _synchronousResponse$ = synchronousResponse.transferables, transferables = _synchronousResponse$ === undefined ? [] : _synchronousResponse$;
                                _context.t1 = receiver;
                                _context.t2 = { id: id, result: result };
                                _context.next = 27;
                                return isSupportingTransferables;

                            case 27:
                                if (!_context.sent) {
                                    _context.next = 31;
                                    break;
                                }

                                _context.t3 = transferables;
                                _context.next = 32;
                                break;

                            case 31:
                                _context.t3 = [];

                            case 32:
                                _context.t4 = _context.t3;

                                _context.t1.postMessage.call(_context.t1, _context.t2, _context.t4);

                            case 34:
                                _context.next = 40;
                                break;

                            case 36:
                                _context.prev = 36;
                                _context.t5 = _context["catch"](1);
                                message = _context.t5.message, _err$status = _context.t5.status, status = _err$status === undefined ? -32603 : _err$status;

                                receiver.postMessage({ error: { code: status, message: message }, id: id });

                            case 40:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[1, 36]]);
            }));
        };
    };

    var CLEAN_UP_FUNCTIONS = new Map();
    var extendWorkerImplementation = function extendWorkerImplementation(createWorker, partialWorkerImplementation) {
        // @todo The spread operator can't be used here because TypeScript does not believe that partialWorkerImplementation is an object.
        return Object.assign({}, partialWorkerImplementation, {
            connect: function connect(_ref) {
                var port = _ref.port;

                port.start();
                var destroyWorker = createWorker(port, partialWorkerImplementation);
                var portId = fastUniqueNumbers.generateUniqueNumber(CLEAN_UP_FUNCTIONS);
                CLEAN_UP_FUNCTIONS.set(portId, function () {
                    destroyWorker();
                    port.close();
                    CLEAN_UP_FUNCTIONS.delete(portId);
                });
                return { result: portId };
            },
            disconnect: function disconnect(_ref2) {
                var portId = _ref2.portId;

                var cleanUp = CLEAN_UP_FUNCTIONS.get(portId);
                if (cleanUp === undefined) {
                    throw renderUnknownPortIdError({ portId: portId.toString() });
                }
                cleanUp();
                return { result: null };
            }
        });
    };

    // Bug #1: Safari does currently not support to use transferables.
    var isSupportingTransferables = new Promise(function (resolve) {
        var arrayBuffer = new ArrayBuffer(0);

        var _ref = new MessageChannel(),
            port1 = _ref.port1,
            port2 = _ref.port2;

        port1.onmessage = function (_ref2) {
            var data = _ref2.data;
            return resolve(data !== null);
        };
        port2.postMessage(arrayBuffer, [arrayBuffer]);
    });

    var createWorker = function createWorker(receiver, workerImplementation) {
        var fullWorkerImplementation = extendWorkerImplementation(createWorker, workerImplementation);
        var messageHandler = createMessageHandler(receiver, fullWorkerImplementation, isSupportingTransferables);
        receiver.addEventListener('message', messageHandler);
        return function () {
            return receiver.removeEventListener('message', messageHandler);
        };
    };

    exports.createWorker = createWorker;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
