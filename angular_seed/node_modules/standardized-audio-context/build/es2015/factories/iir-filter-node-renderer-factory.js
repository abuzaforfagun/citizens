import * as tslib_1 from "tslib";
import { filterBuffer } from '../helpers/filter-buffer';
import { getNativeAudioNode } from '../helpers/get-native-audio-node';
import { isOwnedByContext } from '../helpers/is-owned-by-context';
import { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';
const filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
    const feedbackLength = feedback.length;
    const feedforwardLength = feedforward.length;
    const minLength = Math.min(feedbackLength, feedforwardLength);
    if (feedback[0] !== 1) {
        for (let i = 0; i < feedbackLength; i += 1) {
            feedforward[i] /= feedback[0];
        }
        for (let i = 1; i < feedforwardLength; i += 1) {
            feedback[i] /= feedback[0];
        }
    }
    const bufferLength = 32;
    const xBuffer = new Float32Array(bufferLength);
    const yBuffer = new Float32Array(bufferLength);
    const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
    const numberOfChannels = renderedBuffer.numberOfChannels;
    for (let i = 0; i < numberOfChannels; i += 1) {
        const input = renderedBuffer.getChannelData(i);
        const output = filteredBuffer.getChannelData(i);
        // @todo Add a test which checks support for TypedArray.prototype.fill().
        xBuffer.fill(0);
        yBuffer.fill(0);
        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);
    }
    return filteredBuffer;
};
export const createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) => {
    return (feedback, feedforward) => {
        let nativeAudioNode = null;
        return {
            render: (proxy, nativeOfflineAudioContext) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (nativeAudioNode !== null) {
                    return nativeAudioNode;
                }
                if (nativeOfflineAudioContextConstructor === null) {
                    throw new Error(); // @todo
                }
                nativeAudioNode = getNativeAudioNode(proxy);
                try {
                    // Throw an error if the native factory method is not supported.
                    // @todo Use a simple if clause instead of throwing an error.
                    if (nativeOfflineAudioContext.createIIRFilter === undefined) {
                        throw new Error();
                    }
                    /*
                     * If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created
                     * again.
                     */
                    if (!isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext)) {
                        nativeAudioNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
                    }
                    return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode)
                        .then(() => nativeAudioNode);
                    // Bug #9: Safari does not support IIRFilterNodes.
                }
                catch (err) {
                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(
                    // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.
                    proxy.context.destination.channelCount, 
                    // Bug #17: Safari does not yet expose the length.
                    proxy.context.length, nativeOfflineAudioContext.sampleRate);
                    return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination)
                        .then(() => renderNativeOfflineAudioContext(partialOfflineAudioContext))
                        .then((renderedBuffer) => {
                        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);
                        audioBufferSourceNode.buffer = filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
                        audioBufferSourceNode.start(0);
                        nativeAudioNode = audioBufferSourceNode;
                        return nativeAudioNode;
                    });
                }
            })
        };
    };
};
//# sourceMappingURL=/build/es2015/factories/iir-filter-node-renderer-factory.js.map