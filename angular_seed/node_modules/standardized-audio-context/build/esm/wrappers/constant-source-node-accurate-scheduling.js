export var wrapConstantSourceNodeAccurateScheduling = function (constantSourceNode, nativeContext) {
    var gainNode = nativeContext.createGain();
    constantSourceNode.connect(gainNode);
    var disconnectGainNode = (function (disconnect) {
        return function () {
            disconnect.call(constantSourceNode, gainNode);
            constantSourceNode.removeEventListener('ended', disconnectGainNode);
        };
    })(constantSourceNode.disconnect);
    constantSourceNode.addEventListener('ended', disconnectGainNode);
    constantSourceNode.connect = (function (destination, output, input) {
        if (output === void 0) { output = 0; }
        if (input === void 0) { input = 0; }
        if (destination instanceof AudioNode) {
            // Bug #11: Safari does not support chaining yet, but that wrapper should not be used in Safari.
            return gainNode.connect.call(gainNode, destination, output, input);
        }
        // @todo This return statement is necessary to satisfy TypeScript.
        return gainNode.connect.call(gainNode, destination, output);
    });
    constantSourceNode.disconnect = function () {
        gainNode.disconnect.apply(gainNode, arguments);
    };
    var startTime = 0;
    var stopTime = null;
    var scheduleEnvelope = function () {
        gainNode.gain.cancelScheduledValues(0);
        gainNode.gain.setValueAtTime(0, 0);
        if (stopTime === null || startTime < stopTime) {
            gainNode.gain.setValueAtTime(1, startTime);
        }
        if (stopTime !== null && startTime < stopTime) {
            gainNode.gain.setValueAtTime(0, stopTime);
        }
    };
    constantSourceNode.start = (function (start) {
        return function (when) {
            if (when === void 0) { when = 0; }
            start.call(constantSourceNode, when);
            startTime = when;
            scheduleEnvelope();
        };
    })(constantSourceNode.start);
    constantSourceNode.stop = (function (stop) {
        return function (when) {
            if (when === void 0) { when = 0; }
            stop.call(constantSourceNode, when);
            stopTime = when;
            scheduleEnvelope();
        };
    })(constantSourceNode.stop);
};
//# sourceMappingURL=/build/es2015/wrappers/constant-source-node-accurate-scheduling.js.map