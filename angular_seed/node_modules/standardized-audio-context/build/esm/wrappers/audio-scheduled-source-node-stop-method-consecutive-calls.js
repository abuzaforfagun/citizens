export var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function (nativeAudioScheduledSourceNode, nativeContext) {
    var gainNode = nativeContext.createGain();
    nativeAudioScheduledSourceNode.connect(gainNode);
    var disconnectGainNode = (function (disconnect) {
        return function () {
            disconnect.call(nativeAudioScheduledSourceNode, gainNode);
            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);
        };
    })(nativeAudioScheduledSourceNode.disconnect);
    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);
    nativeAudioScheduledSourceNode.connect = (function (destination, output, input) {
        if (output === void 0) { output = 0; }
        if (input === void 0) { input = 0; }
        if (destination instanceof AudioNode) {
            gainNode.connect.call(gainNode, destination, output, input);
            // Bug #11: Safari does not support chaining yet.
            return destination;
        }
        // @todo This return statement is necessary to satisfy TypeScript.
        return gainNode.connect.call(gainNode, destination, output);
    });
    nativeAudioScheduledSourceNode.disconnect = function () {
        gainNode.disconnect.apply(gainNode, arguments);
    };
    nativeAudioScheduledSourceNode.stop = (function (stop) {
        var isStopped = false;
        return function (when) {
            if (when === void 0) { when = 0; }
            if (isStopped) {
                try {
                    stop.call(nativeAudioScheduledSourceNode, when);
                }
                catch (err) {
                    gainNode.gain.setValueAtTime(0, when);
                }
            }
            else {
                stop.call(nativeAudioScheduledSourceNode, when);
                isStopped = true;
            }
        };
    })(nativeAudioScheduledSourceNode.stop);
};
//# sourceMappingURL=/build/es2015/wrappers/audio-scheduled-source-node-stop-method-consecutive-calls.js.map