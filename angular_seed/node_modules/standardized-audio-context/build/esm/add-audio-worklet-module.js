import { createAbortError } from './factories/abort-error';
import { createNotSupportedError } from './factories/not-supported-error';
import { NODE_NAME_TO_PROCESSOR_DEFINITION_MAPS } from './globals';
import { getNativeContext } from './helpers/get-native-context';
import { isConstructible } from './helpers/is-constructible';
var verifyParameterDescriptors = function (parameterDescriptors) {
    if (!Array.isArray(parameterDescriptors)) {
        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');
    }
};
var verifyProcessorCtor = function (processorCtor) {
    if (!isConstructible(processorCtor)) {
        throw new TypeError('The given value for processorCtor should be a constructor.');
    }
    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {
        throw new TypeError('The given value for processorCtor should have a prototype.');
    }
    if (typeof processorCtor.prototype.process !== 'function') {
        throw new TypeError('The given value for processorCtor should have a callable process() function.');
    }
};
var ongoingRequests = new WeakMap();
var resolvedRequests = new WeakMap();
export var addAudioWorkletModule = function (context, moduleURL, options) {
    if (options === void 0) { options = { credentials: 'omit' }; }
    var nativeContext = getNativeContext(context);
    // Bug #59: Only Chrome Canary does implement the audioWorklet property.
    // @todo Define the native interface as part of the native AudioContext.
    if (nativeContext.audioWorklet !== undefined) {
        return fetch(moduleURL)
            .then(function (response) {
            if (response.ok) {
                return response.text();
            }
            throw createAbortError();
        })
            .then(function (source) {
            /*
             * Bug #86: Chrome Canary does not invoke the process() function if the corresponding AudioWorkletNode has no output.
             *
             * This is the unminified version of the code used below:
             *
             * ```js
             * ((registerProcessor) => {${ source }})((name, processorCtor) => registerProcessor(name, class extends processorCtor {
             *
             *     constructor (options) {
             *         const { hasNoOutput, ...otherParameterData } = options.parameterData;
             *
             *         if (hasNoOutput === 1) {
             *             super({ ...options, numberOfOutputs: 0, outputChannelCount: [ ], parameterData: otherParameterData });
             *
             *             this._hasNoOutput = true;
             *         } else {
             *             super(options);
             *
             *             this._hasNoOutput = false;
             *         }
             *     }
             *
             *     process (inputs, outputs, parameters) {
             *         return super.process(inputs, (this._hasNoOutput) ? [ ] : outputs, parameters);
             *     }
             *
             * }))
             * ```
             */
            var wrappedSource = "(registerProcessor=>{" + source + "})((n,p)=>registerProcessor(n,class extends p{constructor(o){const{hasNoOutput,...q}=o.parameterData;if(hasNoOutput===1){super({...o,numberOfOutputs:0,outputChannelCount:[],parameterData:q});this._h=true}else{super(o);this._h=false}}process(i,o,p){return super.process(i,(this._h)?[]:o,p)}}))"; // tslint:disable-line:max-line-length
            var blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });
            var url = URL.createObjectURL(blob);
            return nativeContext.audioWorklet.addModule(url, options);
        });
    }
    else {
        var resolvedRequestsOfContext = resolvedRequests.get(context);
        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {
            return Promise.resolve();
        }
        var ongoingRequestsOfContext = ongoingRequests.get(context);
        if (ongoingRequestsOfContext !== undefined) {
            var promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
            if (promiseOfOngoingRequest !== undefined) {
                return promiseOfOngoingRequest;
            }
        }
        var promise = fetch(moduleURL)
            .then(function (response) {
            if (response.ok) {
                return response.text();
            }
            throw createAbortError();
        })
            .then(function (source) {
            var fn = new Function('AudioWorkletProcessor', 'currentFrame', 'currentTime', 'global', 'registerProcessor', 'sampleRate', 'self', 'window', source);
            var globalScope = Object.create(null, {
                currentFrame: {
                    get: function () {
                        return nativeContext.currentTime * nativeContext.sampleRate;
                    }
                },
                currentTime: {
                    get: function () {
                        return nativeContext.currentTime;
                    }
                },
                sampleRate: {
                    get: function () {
                        return nativeContext.sampleRate;
                    }
                }
            });
            // @todo Evaluating the given source code is a possible security problem.
            fn(/** @class */ (function () {
                function AudioWorkletProcessor() {
                }
                return AudioWorkletProcessor;
            }()), globalScope.currentFrame, globalScope.currentTime, undefined, function (name, processorCtor) {
                if (name.trim() === '') {
                    throw createNotSupportedError();
                }
                var nodeNameToProcessorDefinitionMap = NODE_NAME_TO_PROCESSOR_DEFINITION_MAPS.get(nativeContext);
                if (nodeNameToProcessorDefinitionMap !== undefined) {
                    if (nodeNameToProcessorDefinitionMap.has(name)) {
                        throw createNotSupportedError();
                    }
                    verifyProcessorCtor(processorCtor);
                    verifyParameterDescriptors(processorCtor.parameterDescriptors);
                    nodeNameToProcessorDefinitionMap.set(name, processorCtor);
                }
                else {
                    verifyProcessorCtor(processorCtor);
                    verifyParameterDescriptors(processorCtor.parameterDescriptors);
                    NODE_NAME_TO_PROCESSOR_DEFINITION_MAPS.set(nativeContext, new Map([[name, processorCtor]]));
                }
            }, globalScope.sampleRate, undefined, undefined);
        })
            .catch(function (err) {
            if (err.name === 'SyntaxError') {
                throw createAbortError();
            }
            throw err;
        });
        if (ongoingRequestsOfContext === undefined) {
            ongoingRequests.set(context, new Map([[moduleURL, promise]]));
        }
        else {
            ongoingRequestsOfContext.set(moduleURL, promise);
        }
        promise
            .then(function () {
            var rslvdRqstsFCntxt = resolvedRequests.get(context);
            if (rslvdRqstsFCntxt === undefined) {
                resolvedRequests.set(context, new Set([moduleURL]));
            }
            else {
                rslvdRqstsFCntxt.add(moduleURL);
            }
        })
            .catch(function () { }) // tslint:disable-line:no-empty
            // @todo Use finally when it becomes available in all supported browsers.
            .then(function () {
            var ngngRqstsFCntxt = ongoingRequests.get(context);
            if (ngngRqstsFCntxt !== undefined) {
                ngngRqstsFCntxt.delete(moduleURL);
            }
        });
        return promise;
    }
};
//# sourceMappingURL=/build/es2015/add-audio-worklet-module.js.map