import { deallocate } from 'async-array-buffer';
import { createDataCloneError } from './factories/data-clone-error';
import { createEncodingError } from './factories/encoding-error';
import { DETACHED_ARRAY_BUFFERS } from './globals';
import { cacheTestResult } from './helpers/cache-test-result';
import { testAudioBufferCopyChannelMethodsSubarraySupport } from './support-testers/audio-buffer-copy-channel-methods-subarray';
import { testPromiseSupport } from './support-testers/promise';
import { wrapAudioBufferCopyChannelMethods } from './wrappers/audio-buffer-copy-channel-methods';
import { wrapAudioBufferCopyChannelMethodsSubarray } from './wrappers/audio-buffer-copy-channel-methods-subarray';
var isSupportingCopyChannelMethodsSubarray = function (nativeAudioBuffer) { return cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, function () { return testAudioBufferCopyChannelMethodsSubarraySupport(nativeAudioBuffer); }); };
var isSupportingPromises = function (nativeContext) { return cacheTestResult(testPromiseSupport, function () { return testPromiseSupport(nativeContext); }); };
export var decodeAudioData = function (nativeContext, audioData) {
    // Bug #43: Only Chrome and Opera do throw a DataCloneError.
    if (DETACHED_ARRAY_BUFFERS.has(audioData)) {
        var err = createDataCloneError();
        return Promise.reject(err);
    }
    // The audioData parameter maybe of a type which can't be added to a WeakSet.
    try {
        DETACHED_ARRAY_BUFFERS.add(audioData);
    }
    catch (err) {
        // Ignore errors.
    }
    // Bug #21: Safari does not support promises yet.
    if (isSupportingPromises(nativeContext)) {
        var promise = nativeContext
            .decodeAudioData(audioData)
            .catch(function (err) {
            // Bug #27: Edge is rejecting invalid arrayBuffers with a DOMException.
            if (err instanceof DOMException && err.name === 'NotSupportedError') {
                throw new TypeError();
            }
            throw err;
        });
        setTimeout(function () {
            try {
                deallocate(audioData);
            }
            catch (err) { /* Ignore errors. */ }
        });
        return promise;
    }
    // Bug #21: Safari does not return a Promise yet.
    return new Promise(function (resolve, reject) {
        var complete = function () {
            try {
                deallocate(audioData);
            }
            catch (err) { /* Ignore errors. */ }
        };
        var fail = function (err) {
            reject(err);
            complete();
        };
        var succeed = function (dBffrWrppr) {
            resolve(dBffrWrppr);
            complete();
        };
        // Bug #26: Safari throws a synchronous error.
        try {
            // Bug #1: Safari requires a successCallback.
            nativeContext.decodeAudioData(audioData, function (audioBuffer) {
                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                if (typeof audioBuffer.copyFromChannel !== 'function') {
                    wrapAudioBufferCopyChannelMethods(audioBuffer);
                    // Bug #42: Firefox does not yet fully support copyFromChannel() and copyToChannel().
                }
                else if (!isSupportingCopyChannelMethodsSubarray(audioBuffer)) {
                    wrapAudioBufferCopyChannelMethodsSubarray(audioBuffer);
                }
                succeed(audioBuffer);
            }, function (err) {
                // Bug #4: Safari returns null instead of an error.
                if (err === null) {
                    fail(createEncodingError());
                }
                else {
                    fail(err);
                }
            });
        }
        catch (err) {
            fail(err);
        }
    });
};
//# sourceMappingURL=/build/es2015/decode-audio-data.js.map