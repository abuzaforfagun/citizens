var _this = this;
import * as tslib_1 from "tslib";
import { connectAudioParam } from '../helpers/connect-audio-param';
import { createNestedArrays } from '../helpers/create-nested-arrays';
import { getAudioNodeConnections } from '../helpers/get-audio-node-connections';
import { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';
import { getNativeAudioNode } from '../helpers/get-native-audio-node';
import { isOwnedByContext } from '../helpers/is-owned-by-context';
import { renderAutomation } from '../helpers/render-automation';
import { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';
var processBuffer = function (proxy, renderedBuffer, nativeOfflineAudioContext, options, processorDefinition) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
    var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop_1, i, state_1;
    return tslib_1.__generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                length = renderedBuffer.length;
                numberOfInputChannels = options.channelCount * options.numberOfInputs;
                numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) { return sum + value; }, 0);
                processedBuffer = (numberOfOutputChannels === 0) ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, renderedBuffer.sampleRate);
                if (processorDefinition === undefined) {
                    throw new Error();
                }
                audioNodeConnections = getAudioNodeConnections(proxy);
                return [4 /*yield*/, getAudioWorkletProcessor(nativeOfflineAudioContext, proxy)];
            case 1:
                audioWorkletProcessor = _a.sent();
                inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
                outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);
                parameters = Array
                    .from(proxy.parameters.keys())
                    .reduce(function (prmtrs, name, index) {
                    return tslib_1.__assign({}, prmtrs, (_a = {}, _a[name] = renderedBuffer.getChannelData(numberOfInputChannels + index), _a));
                    var _a;
                }, {});
                _loop_1 = function (i) {
                    for (var j = 0; j < options.numberOfInputs; j += 1) {
                        for (var k = 0; k < options.channelCount; k += 1) {
                            // Bug #5: Safari does not support copyFromChannel().
                            var slicedRenderedBuffer = renderedBuffer
                                .getChannelData(k)
                                .slice(i, i + 128);
                            inputs[j][k].set(slicedRenderedBuffer);
                        }
                    }
                    processorDefinition.parameterDescriptors.forEach(function (_a, index) {
                        var name = _a.name;
                        var slicedRenderedBuffer = renderedBuffer
                            .getChannelData(numberOfInputChannels + index)
                            .slice(i, i + 128);
                        parameters[name].set(slicedRenderedBuffer);
                    });
                    try {
                        var potentiallyEmptyInputs = inputs
                            .map(function (input, index) {
                            if (audioNodeConnections.inputs[index].size === 0) {
                                return [];
                            }
                            return input;
                        });
                        var activeSourceFlag = audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);
                        if (processedBuffer !== null) {
                            for (var j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
                                for (var k = 0; k < options.outputChannelCount[j]; k += 1) {
                                    // Bug #5: Safari does not support copyToChannel().
                                    processedBuffer
                                        .getChannelData(outputChannelSplitterNodeOutput + k)
                                        .set(outputs[j][k], i);
                                }
                                outputChannelSplitterNodeOutput += options.outputChannelCount[j];
                            }
                        }
                        if (!activeSourceFlag) {
                            return "break";
                        }
                    }
                    catch (err) {
                        if (proxy.onprocessorerror !== null) {
                            proxy.onprocessorerror.call(null, new ErrorEvent('processorerror'));
                        }
                        return "break";
                    }
                };
                for (i = 0; i < length; i += 128) {
                    state_1 = _loop_1(i);
                    if (state_1 === "break")
                        break;
                }
                return [2 /*return*/, processedBuffer];
        }
    });
}); };
export var createAudioWorkletNodeRendererFactory = function (connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, disconnectMultipleOutputs, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) {
    return function (name, options, processorDefinition) {
        var nativeAudioNode = null;
        return {
            render: function (proxy, nativeOfflineAudioContext) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var _this = this;
                var numberOfInputChannels, numberOfParameters, partialOfflineAudioContext_1, gainNodes, inputChannelSplitterNodes, i, constantSourceNodes, inputChannelMergerNode, i, j, _i, _a, _b, index, constantSourceNode, _c, _d, _e, nm, audioParam, _f, _g, _h, nm, audioParam;
                return tslib_1.__generator(this, function (_j) {
                    switch (_j.label) {
                        case 0:
                            if (nativeAudioNode !== null) {
                                return [2 /*return*/, nativeAudioNode];
                            }
                            nativeAudioNode = getNativeAudioNode(proxy);
                            if (!(nativeAudioWorkletNodeConstructor === null)) return [3 /*break*/, 2];
                            if (processorDefinition === undefined) {
                                throw new Error('Missing the processor definition.');
                            }
                            if (nativeOfflineAudioContextConstructor === null) {
                                throw new Error('Missing the native (Offline)AudioContext constructor.');
                            }
                            numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
                            numberOfParameters = processorDefinition.parameterDescriptors.length;
                            partialOfflineAudioContext_1 = new nativeOfflineAudioContextConstructor(numberOfInputChannels + numberOfParameters, 
                            // Ceil the length to the next full render quantum.
                            // Bug #17: Safari does not yet expose the length.
                            Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);
                            gainNodes = [];
                            inputChannelSplitterNodes = [];
                            for (i = 0; i < options.numberOfInputs; i += 1) {
                                gainNodes.push(createNativeGainNode(partialOfflineAudioContext_1, {
                                    channelCount: options.channelCount,
                                    channelCountMode: options.channelCountMode,
                                    channelInterpretation: options.channelInterpretation,
                                    gain: 1
                                }));
                                inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext_1, {
                                    channelCount: options.channelCount,
                                    channelCountMode: 'explicit',
                                    channelInterpretation: 'discrete',
                                    numberOfOutputs: options.channelCount
                                }));
                            }
                            return [4 /*yield*/, Promise
                                    .all(Array
                                    .from(proxy.parameters.values())
                                    .map(function (audioParam) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                    var constantSourceNode;
                                    return tslib_1.__generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext_1, {
                                                    channelCount: 1,
                                                    channelCountMode: 'explicit',
                                                    channelInterpretation: 'discrete',
                                                    offset: audioParam.value
                                                });
                                                return [4 /*yield*/, renderAutomation(proxy.context, partialOfflineAudioContext_1, audioParam, constantSourceNode.offset)];
                                            case 1:
                                                _a.sent();
                                                return [2 /*return*/, constantSourceNode];
                                        }
                                    });
                                }); }))];
                        case 1:
                            constantSourceNodes = _j.sent();
                            inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext_1, {
                                numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
                            });
                            for (i = 0; i < options.numberOfInputs; i += 1) {
                                gainNodes[i].connect(inputChannelSplitterNodes[i]);
                                for (j = 0; j < options.channelCount; j += 1) {
                                    inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);
                                }
                            }
                            for (_i = 0, _a = Array.from(constantSourceNodes.entries()); _i < _a.length; _i++) {
                                _b = _a[_i], index = _b[0], constantSourceNode = _b[1];
                                constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
                                constantSourceNode.start(0);
                            }
                            inputChannelMergerNode.connect(partialOfflineAudioContext_1.destination);
                            return [2 /*return*/, Promise
                                    .all(gainNodes
                                    .map(function (gainNode) { return renderInputsOfAudioNode(proxy, partialOfflineAudioContext_1, gainNode); }))
                                    .then(function () { return renderNativeOfflineAudioContext(partialOfflineAudioContext_1); })
                                    .then(function (renderedBuffer) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                                    var audioBufferSourceNode, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, processedBuffer, i, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, outputAudioNodes;
                                    return tslib_1.__generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);
                                                numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) { return sum + value; }, 0);
                                                outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {
                                                    channelCount: Math.max(1, numberOfOutputChannels),
                                                    channelCountMode: 'explicit',
                                                    channelInterpretation: 'discrete',
                                                    numberOfOutputs: Math.max(1, numberOfOutputChannels)
                                                });
                                                outputChannelMergerNodes = [];
                                                for (i = 0; i < proxy.numberOfOutputs; i += 1) {
                                                    outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {
                                                        numberOfInputs: options.outputChannelCount[i]
                                                    }));
                                                }
                                                return [4 /*yield*/, processBuffer(proxy, renderedBuffer, nativeOfflineAudioContext, options, processorDefinition)];
                                            case 1:
                                                processedBuffer = _a.sent();
                                                if (processedBuffer !== null) {
                                                    audioBufferSourceNode.buffer = processedBuffer;
                                                    audioBufferSourceNode.start(0);
                                                }
                                                audioBufferSourceNode.connect(outputChannelSplitterNode);
                                                for (i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {
                                                    outputChannelMergerNode = outputChannelMergerNodes[i];
                                                    for (j = 0; j < options.outputChannelCount[i]; j += 1) {
                                                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
                                                    }
                                                    outputChannelSplitterNodeOutput += options.outputChannelCount[i];
                                                }
                                                outputAudioNodes = (options.numberOfOutputs === 0) ?
                                                    [outputChannelSplitterNode] :
                                                    outputChannelMergerNodes;
                                                audioBufferSourceNode.connect = function () {
                                                    var args = [];
                                                    for (var _i = 0; _i < arguments.length; _i++) {
                                                        args[_i] = arguments[_i];
                                                    }
                                                    return connectMultipleOutputs(outputAudioNodes, args[0], args[1], args[2]);
                                                };
                                                audioBufferSourceNode.disconnect = function () {
                                                    var args = [];
                                                    for (var _i = 0; _i < arguments.length; _i++) {
                                                        args[_i] = arguments[_i];
                                                    }
                                                    return disconnectMultipleOutputs(outputAudioNodes, args[0], args[1], args[2]);
                                                };
                                                nativeAudioNode = audioBufferSourceNode;
                                                return [2 /*return*/, nativeAudioNode];
                                        }
                                    });
                                }); })];
                        case 2:
                            if (!!isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext)) return [3 /*break*/, 7];
                            nativeAudioNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);
                            _c = 0, _d = Array.from(proxy.parameters.entries());
                            _j.label = 3;
                        case 3:
                            if (!(_c < _d.length)) return [3 /*break*/, 6];
                            _e = _d[_c], nm = _e[0], audioParam = _e[1];
                            return [4 /*yield*/, renderAutomation(proxy.context, nativeOfflineAudioContext, audioParam, nativeAudioNode.parameters.get(nm))];
                        case 4:
                            _j.sent();
                            _j.label = 5;
                        case 5:
                            _c++;
                            return [3 /*break*/, 3];
                        case 6: return [3 /*break*/, 11];
                        case 7:
                            _f = 0, _g = Array.from(proxy.parameters.entries());
                            _j.label = 8;
                        case 8:
                            if (!(_f < _g.length)) return [3 /*break*/, 11];
                            _h = _g[_f], nm = _h[0], audioParam = _h[1];
                            return [4 /*yield*/, connectAudioParam(proxy.context, nativeOfflineAudioContext, audioParam, nativeAudioNode.parameters.get(nm))];
                        case 9:
                            _j.sent();
                            _j.label = 10;
                        case 10:
                            _f++;
                            return [3 /*break*/, 8];
                        case 11: return [4 /*yield*/, renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode)];
                        case 12:
                            _j.sent();
                            return [2 /*return*/, nativeAudioNode];
                    }
                });
            }); }
        };
    };
};
//# sourceMappingURL=/build/es2015/factories/audio-worklet-node-renderer-factory.js.map