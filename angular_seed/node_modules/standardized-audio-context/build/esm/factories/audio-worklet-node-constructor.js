import * as tslib_1 from "tslib";
import { NODE_NAME_TO_PROCESSOR_DEFINITION_MAPS } from '../globals';
import { getNativeContext } from '../helpers/get-native-context';
import { ReadOnlyMap } from '../read-only-map';
var DEFAULT_OPTIONS = {
    channelCount: 2,
    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
    channelCountMode: 'explicit',
    channelInterpretation: 'speakers',
    numberOfInputs: 1,
    numberOfOutputs: 1,
    outputChannelCount: undefined,
    parameterData: {},
    processorOptions: null
};
var createChannelCount = function (length) {
    var channelCount = [];
    for (var i = 0; i < length; i += 1) {
        channelCount.push(1);
    }
    return channelCount;
};
var sanitizedOptions = function (options) {
    return tslib_1.__assign({}, options, { outputChannelCount: (options.outputChannelCount !== undefined) ?
            options.outputChannelCount :
            (options.numberOfInputs === 1 && options.numberOfOutputs === 1) ?
                /*
                 * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
                 * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
                 * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
                 */
                [options.channelCount] :
                createChannelCount(options.numberOfOutputs), 
        // Bug #66: The default value of processorOptions should be null, but Chrome Canary doesn't like it.
        processorOptions: (options.processorOptions === null) ? {} : options.processorOptions });
};
export var createAudioWorkletNodeConstructor = function (createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, noneAudioDestinationNodeConstructor) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(AudioWorkletNode, _super);
        function AudioWorkletNode(context, name, options) {
            if (options === void 0) { options = DEFAULT_OPTIONS; }
            var _this = this;
            var nativeContext = getNativeContext(context);
            var mergedOptions = sanitizedOptions(tslib_1.__assign({}, DEFAULT_OPTIONS, options));
            var nodeNameToProcessorDefinitionMap = NODE_NAME_TO_PROCESSOR_DEFINITION_MAPS.get(nativeContext);
            var processorDefinition = (nodeNameToProcessorDefinitionMap === undefined) ?
                undefined :
                nodeNameToProcessorDefinitionMap.get(name);
            var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContext, nativeAudioWorkletNodeConstructor, name, processorDefinition, mergedOptions);
            var isOffline = isNativeOfflineAudioContext(nativeContext);
            var audioWorkletNodeRenderer = (isOffline) ?
                createAudioWorkletNodeRenderer(name, mergedOptions, processorDefinition) :
                null;
            _this = _super.call(this, context, nativeAudioWorkletNode, audioWorkletNodeRenderer) || this;
            var parameters = [];
            nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {
                var audioParam = createAudioParam(context, isOffline, nativeAudioParam);
                parameters.push([nm, audioParam]);
            });
            _this._nativeAudioWorkletNode = nativeAudioWorkletNode;
            // Bug #86 & #87: Every browser but Firefox needs to get an unused output which should not be exposed.
            _this._numberOfOutputs = (options.numberOfOutputs === 0) ? 0 : _this._nativeAudioWorkletNode.numberOfOutputs;
            _this._parameters = new ReadOnlyMap(parameters);
            // Bug #86 & #87: Every browser but Firefox needs an output to be connected.
            if (options.numberOfOutputs === 0) {
                _this.connect(context.destination);
            }
            return _this;
        }
        Object.defineProperty(AudioWorkletNode.prototype, "numberOfOutputs", {
            get: function () {
                return this._numberOfOutputs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioWorkletNode.prototype, "onprocessorerror", {
            get: function () {
                return this._nativeAudioWorkletNode.onprocessorerror;
            },
            set: function (value) {
                this._nativeAudioWorkletNode.onprocessorerror = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioWorkletNode.prototype, "parameters", {
            get: function () {
                if (this._parameters === null) {
                    return this._nativeAudioWorkletNode.parameters;
                }
                return this._parameters;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AudioWorkletNode.prototype, "port", {
            get: function () {
                return this._nativeAudioWorkletNode.port;
            },
            enumerable: true,
            configurable: true
        });
        return AudioWorkletNode;
    }(noneAudioDestinationNodeConstructor));
};
//# sourceMappingURL=/build/es2015/factories/audio-worklet-node-constructor.js.map