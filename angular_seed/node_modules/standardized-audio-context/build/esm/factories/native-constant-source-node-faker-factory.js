import * as tslib_1 from "tslib";
export var createNativeConstantSourceNodeFakerFactory = function (createNativeAudioBufferSourceNode, createNativeGainNode) {
    return function (nativeAudioContext, _a) {
        var offset = _a.offset, audioNodeOptions = tslib_1.__rest(_a, ["offset"]);
        // @todo Safari does not play/loop 1 sample buffers. This should be covered by an expectation test.
        var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeAudioContext);
        /*
         * @todo Edge will throw a NotSupportedError when calling createBuffer() on a closed context. That's why the audioBuffer is created
         * after the audioBufferSourceNode in this case. If the context is closed createNativeAudioBufferSourceNode() will throw the
         * expected error and createBuffer() never gets called.
         */
        var audioBuffer = nativeAudioContext.createBuffer(1, 2, nativeAudioContext.sampleRate);
        var gainNode = createNativeGainNode(nativeAudioContext, tslib_1.__assign({}, audioNodeOptions, { gain: offset }));
        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
        var channelData = audioBuffer.getChannelData(0);
        channelData[0] = 1;
        channelData[1] = 1;
        audioBufferSourceNode.buffer = audioBuffer;
        audioBufferSourceNode.loop = true;
        audioBufferSourceNode.connect(gainNode);
        return {
            get bufferSize() {
                return undefined;
            },
            get channelCount() {
                return gainNode.channelCount;
            },
            set channelCount(value) {
                gainNode.channelCount = value;
            },
            get channelCountMode() {
                return gainNode.channelCountMode;
            },
            set channelCountMode(value) {
                gainNode.channelCountMode = value;
            },
            get channelInterpretation() {
                return gainNode.channelInterpretation;
            },
            set channelInterpretation(value) {
                gainNode.channelInterpretation = value;
            },
            get context() {
                return gainNode.context;
            },
            get inputs() {
                return undefined;
            },
            get numberOfInputs() {
                return audioBufferSourceNode.numberOfInputs;
            },
            get numberOfOutputs() {
                return gainNode.numberOfOutputs;
            },
            get offset() {
                return gainNode.gain;
            },
            get onended() {
                return audioBufferSourceNode.onended;
            },
            set onended(value) {
                audioBufferSourceNode.onended = value;
            },
            addEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
            },
            connect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (args[2] === undefined) {
                    return gainNode.connect.call(gainNode, args[0], args[1]);
                }
                return gainNode.connect.call(gainNode, args[0], args[1], args[2]);
            },
            disconnect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return gainNode.disconnect.call(gainNode, args[0], args[1], args[2]);
            },
            dispatchEvent: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return audioBufferSourceNode.dispatchEvent(args[0]);
            },
            removeEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
            },
            start: function (when) {
                if (when === void 0) { when = 0; }
                audioBufferSourceNode.start.call(audioBufferSourceNode, when);
            },
            stop: function (when) {
                if (when === void 0) { when = 0; }
                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
            }
        };
    };
};
//# sourceMappingURL=/build/es2015/factories/native-constant-source-node-faker-factory.js.map