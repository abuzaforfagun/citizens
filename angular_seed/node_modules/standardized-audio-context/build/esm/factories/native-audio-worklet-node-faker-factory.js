import * as tslib_1 from "tslib";
import { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';
import { createNestedArrays } from '../helpers/create-nested-arrays';
import { getAudioNodeConnections } from '../helpers/get-audio-node-connections';
import { ReadOnlyMap } from '../read-only-map';
export var createNativeAudioWorkletNodeFakerFactory = function (connectMultipleOutputs, createIndexSizeError, createInvalidStateError, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNotSupportedError, disconnectMultipleOutputs) {
    return function (nativeAudioContext, processorDefinition, options) {
        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {
            throw createNotSupportedError();
        }
        if (options.outputChannelCount !== undefined) {
            if (options.outputChannelCount.length !== options.numberOfOutputs) {
                throw createIndexSizeError();
            }
            // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.
            if (options.outputChannelCount.some(function (channelCount) { return (channelCount < 1); })) {
                throw createNotSupportedError();
            }
        }
        // Bug #61: This is not part of the standard but required for the faker to work.
        if (options.channelCountMode !== 'explicit') {
            throw createNotSupportedError();
        }
        var numberOfInputChannels = options.channelCount * options.numberOfInputs;
        var numberOfOutputChannels = options.outputChannelCount.reduce(function (sum, value) { return sum + value; }, 0);
        var numberOfParameters = processorDefinition.parameterDescriptors.length;
        // Bug #61: This is not part of the standard but required for the faker to work.
        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
            throw createNotSupportedError();
        }
        var messageChannel = new MessageChannel();
        var gainNodes = [];
        var inputChannelSplitterNodes = [];
        for (var i = 0; i < options.numberOfInputs; i += 1) {
            gainNodes.push(createNativeGainNode(nativeAudioContext, {
                channelCount: options.channelCount,
                channelCountMode: options.channelCountMode,
                channelInterpretation: options.channelInterpretation,
                gain: 1
            }));
            inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeAudioContext, {
                channelCount: options.channelCount,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                numberOfOutputs: options.channelCount
            }));
        }
        var constantSourceNodes = [];
        var _loop_1 = function (defaultValue, maxValue, minValue) {
            var constantSourceNode = createNativeConstantSourceNode(nativeAudioContext, {
                channelCount: 1,
                channelCountMode: 'explicit',
                channelInterpretation: 'discrete',
                offset: (defaultValue === undefined) ? 0 : defaultValue
            });
            Object.defineProperties(constantSourceNode.offset, {
                defaultValue: {
                    get: function () { return (defaultValue === undefined) ? 0 : defaultValue; }
                },
                maxValue: {
                    get: function () { return (maxValue === undefined) ? 3.4028234663852886e38 : maxValue; }
                },
                minValue: {
                    get: function () { return (minValue === undefined) ? -3.4028234663852886e38 : minValue; }
                }
            });
            constantSourceNodes.push(constantSourceNode);
        };
        for (var _i = 0, _a = processorDefinition.parameterDescriptors; _i < _a.length; _i++) {
            var _b = _a[_i], defaultValue = _b.defaultValue, maxValue = _b.maxValue, minValue = _b.minValue;
            _loop_1(defaultValue, maxValue, minValue);
        }
        var inputChannelMergerNode = createNativeChannelMergerNode(nativeAudioContext, {
            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
        });
        var bufferSize = 512;
        var scriptProcessorNode = nativeAudioContext.createScriptProcessor(bufferSize, numberOfInputChannels + numberOfParameters, 
        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
        Math.max(1, numberOfOutputChannels));
        var outputChannelSplitterNode = createNativeChannelSplitterNode(nativeAudioContext, {
            channelCount: Math.max(1, numberOfOutputChannels),
            channelCountMode: 'explicit',
            channelInterpretation: 'discrete',
            numberOfOutputs: Math.max(1, numberOfOutputChannels)
        });
        var outputChannelMergerNodes = [];
        for (var i = 0; i < options.numberOfOutputs; i += 1) {
            outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeAudioContext, {
                numberOfInputs: options.outputChannelCount[i]
            }));
        }
        for (var i = 0; i < options.numberOfInputs; i += 1) {
            gainNodes[i].connect(inputChannelSplitterNodes[i]);
            for (var j = 0; j < options.channelCount; j += 1) {
                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, (i * options.channelCount) + j);
            }
        }
        var parameterMap = new ReadOnlyMap(processorDefinition.parameterDescriptors
            .map(function (_a, index) {
            var name = _a.name;
            var constantSourceNode = constantSourceNodes[index];
            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
            constantSourceNode.start(0);
            return [name, constantSourceNode.offset];
        }));
        inputChannelMergerNode.connect(scriptProcessorNode);
        if (options.numberOfOutputs > 0) {
            scriptProcessorNode.connect(outputChannelSplitterNode);
        }
        for (var i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
            var outputChannelMergerNode = outputChannelMergerNodes[i];
            for (var j = 0; j < options.outputChannelCount[i]; j += 1) {
                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
            }
            outputChannelSplitterNodeOutput += options.outputChannelCount[i];
        }
        var onprocessorerror = null;
        // Bug #87: Expose at least one output to make this node connectable.
        var outputAudioNodes = (options.numberOfOutputs === 0) ? [scriptProcessorNode] : outputChannelMergerNodes;
        var faker = {
            get bufferSize() {
                return bufferSize;
            },
            get channelCount() {
                return options.channelCount;
            },
            set channelCount(_) {
                // Bug #61: This is not part of the standard but required for the faker to work.
                throw createInvalidStateError();
            },
            get channelCountMode() {
                return options.channelCountMode;
            },
            set channelCountMode(_) {
                // Bug #61: This is not part of the standard but required for the faker to work.
                throw createInvalidStateError();
            },
            get channelInterpretation() {
                return gainNodes[0].channelInterpretation;
            },
            set channelInterpretation(value) {
                for (var _i = 0, gainNodes_1 = gainNodes; _i < gainNodes_1.length; _i++) {
                    var gainNode = gainNodes_1[_i];
                    gainNode.channelInterpretation = value;
                }
            },
            get context() {
                return gainNodes[0].context;
            },
            get inputs() {
                return gainNodes;
            },
            get numberOfInputs() {
                return options.numberOfInputs;
            },
            get numberOfOutputs() {
                return options.numberOfOutputs;
            },
            get onprocessorerror() {
                return onprocessorerror;
            },
            set onprocessorerror(value) {
                if (value === null || typeof value === 'function') {
                    onprocessorerror = value;
                }
                else {
                    onprocessorerror = null;
                }
            },
            get parameters() {
                return parameterMap;
            },
            get port() {
                return messageChannel.port2;
            },
            addEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return gainNodes[0].addEventListener(args[0], args[1], args[2]);
            },
            connect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return connectMultipleOutputs(outputAudioNodes, args[0], args[1], args[2]);
            },
            disconnect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return disconnectMultipleOutputs(outputAudioNodes, args[0], args[1], args[2]);
            },
            dispatchEvent: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return gainNodes[0].dispatchEvent(args[0]);
            },
            removeEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return gainNodes[0].removeEventListener(args[0], args[1], args[2]);
            }
        };
        processorDefinition.prototype.port = messageChannel.port1;
        var audioWorkletProcessor = null;
        var audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeAudioContext, faker, processorDefinition, options);
        audioWorkletProcessorPromise
            .then(function (dWrkltPrcssr) { return audioWorkletProcessor = dWrkltPrcssr; });
        var inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
        var outputs = createNestedArrays(options.numberOfOutputs, options.outputChannelCount);
        var parameters = processorDefinition.parameterDescriptors
            .reduce(function (prmtrs, _a) {
            var name = _a.name;
            return (tslib_1.__assign({}, prmtrs, (_b = {}, _b[name] = new Float32Array(128), _b)));
            var _b;
        }, {});
        var isActive = true;
        scriptProcessorNode.onaudioprocess = function (_a) {
            var inputBuffer = _a.inputBuffer, outputBuffer = _a.outputBuffer;
            if (audioWorkletProcessor !== null) {
                var _loop_2 = function (i) {
                    for (var j = 0; j < options.numberOfInputs; j += 1) {
                        for (var k = 0; k < options.channelCount; k += 1) {
                            // Bug #5: Safari does not support copyFromChannel().
                            var slicedInputBuffer = inputBuffer
                                .getChannelData(k)
                                .slice(i, i + 128);
                            inputs[j][k].set(slicedInputBuffer);
                        }
                    }
                    processorDefinition.parameterDescriptors.forEach(function (_a, index) {
                        var name = _a.name;
                        var slicedInputBuffer = inputBuffer
                            .getChannelData(numberOfInputChannels + index)
                            .slice(i, i + 128);
                        parameters[name].set(slicedInputBuffer);
                    });
                    try {
                        var audioNodeConnections_1 = getAudioNodeConnections(faker);
                        var potentiallyEmptyInputs = inputs
                            .map(function (input, index) {
                            if (audioNodeConnections_1.inputs[index].size === 0) {
                                return [];
                            }
                            return input;
                        });
                        var activeSourceFlag = audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);
                        isActive = activeSourceFlag;
                        for (var j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
                            for (var k = 0; k < options.outputChannelCount[j]; k += 1) {
                                // Bug #5: Safari does not support copyFromChannel().
                                outputBuffer
                                    .getChannelData(outputChannelSplitterNodeOutput + k)
                                    .set(outputs[j][k], i);
                            }
                            outputChannelSplitterNodeOutput += options.outputChannelCount[j];
                        }
                    }
                    catch (err) {
                        isActive = false;
                        if (onprocessorerror !== null) {
                            onprocessorerror.call(null, new ErrorEvent('processorerror'));
                        }
                    }
                    if (!isActive) {
                        scriptProcessorNode.onaudioprocess = null;
                        return "break";
                    }
                };
                for (var i = 0; i < bufferSize; i += 128) {
                    var state_1 = _loop_2(i);
                    if (state_1 === "break")
                        break;
                }
            }
        };
        return faker;
    };
};
//# sourceMappingURL=/build/es2015/factories/native-audio-worklet-node-faker-factory.js.map