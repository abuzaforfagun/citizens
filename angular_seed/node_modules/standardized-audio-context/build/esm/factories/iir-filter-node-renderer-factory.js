var _this = this;
import * as tslib_1 from "tslib";
import { filterBuffer } from '../helpers/filter-buffer';
import { getNativeAudioNode } from '../helpers/get-native-audio-node';
import { isOwnedByContext } from '../helpers/is-owned-by-context';
import { renderInputsOfAudioNode } from '../helpers/render-inputs-of-audio-node';
var filterFullBuffer = function (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) {
    var feedbackLength = feedback.length;
    var feedforwardLength = feedforward.length;
    var minLength = Math.min(feedbackLength, feedforwardLength);
    if (feedback[0] !== 1) {
        for (var i = 0; i < feedbackLength; i += 1) {
            feedforward[i] /= feedback[0];
        }
        for (var i = 1; i < feedforwardLength; i += 1) {
            feedback[i] /= feedback[0];
        }
    }
    var bufferLength = 32;
    var xBuffer = new Float32Array(bufferLength);
    var yBuffer = new Float32Array(bufferLength);
    var filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
    var numberOfChannels = renderedBuffer.numberOfChannels;
    for (var i = 0; i < numberOfChannels; i += 1) {
        var input = renderedBuffer.getChannelData(i);
        var output = filteredBuffer.getChannelData(i);
        // @todo Add a test which checks support for TypedArray.prototype.fill().
        xBuffer.fill(0);
        yBuffer.fill(0);
        filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);
    }
    return filteredBuffer;
};
export var createIIRFilterNodeRendererFactory = function (createNativeAudioBufferSourceNode, nativeOfflineAudioContextConstructor, renderNativeOfflineAudioContext) {
    return function (feedback, feedforward) {
        var nativeAudioNode = null;
        return {
            render: function (proxy, nativeOfflineAudioContext) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var partialOfflineAudioContext_1;
                return tslib_1.__generator(this, function (_a) {
                    if (nativeAudioNode !== null) {
                        return [2 /*return*/, nativeAudioNode];
                    }
                    if (nativeOfflineAudioContextConstructor === null) {
                        throw new Error(); // @todo
                    }
                    nativeAudioNode = getNativeAudioNode(proxy);
                    try {
                        // Throw an error if the native factory method is not supported.
                        // @todo Use a simple if clause instead of throwing an error.
                        if (nativeOfflineAudioContext.createIIRFilter === undefined) {
                            throw new Error();
                        }
                        /*
                         * If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created
                         * again.
                         */
                        if (!isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext)) {
                            nativeAudioNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
                        }
                        return [2 /*return*/, renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode)
                                .then(function () { return nativeAudioNode; })];
                        // Bug #9: Safari does not support IIRFilterNodes.
                    }
                    catch (err) {
                        partialOfflineAudioContext_1 = new nativeOfflineAudioContextConstructor(
                        // Bug #47: The AudioDestinationNode in Edge and Safari gets not initialized correctly.
                        proxy.context.destination.channelCount, 
                        // Bug #17: Safari does not yet expose the length.
                        proxy.context.length, nativeOfflineAudioContext.sampleRate);
                        return [2 /*return*/, renderInputsOfAudioNode(proxy, partialOfflineAudioContext_1, partialOfflineAudioContext_1.destination)
                                .then(function () { return renderNativeOfflineAudioContext(partialOfflineAudioContext_1); })
                                .then(function (renderedBuffer) {
                                var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext);
                                audioBufferSourceNode.buffer = filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
                                audioBufferSourceNode.start(0);
                                nativeAudioNode = audioBufferSourceNode;
                                return nativeAudioNode;
                            })];
                    }
                    return [2 /*return*/];
                });
            }); }
        };
    };
};
//# sourceMappingURL=/build/es2015/factories/iir-filter-node-renderer-factory.js.map