import { filterBuffer } from '../helpers/filter-buffer';
function divide(a, b) {
    var denominator = (b[0] * b[0]) + (b[1] * b[1]);
    return [(((a[0] * b[0]) + (a[1] * b[1])) / denominator), (((a[1] * b[0]) - (a[0] * b[1])) / denominator)];
}
function multiply(a, b) {
    return [((a[0] * b[0]) - (a[1] * b[1])), ((a[0] * b[1]) + (a[1] * b[0]))];
}
function evaluatePolynomial(coefficient, z) {
    var result = [0, 0];
    for (var i = coefficient.length - 1; i >= 0; i -= 1) {
        result = multiply(result, z);
        result[0] += coefficient[i];
    }
    return result;
}
export var createNativeIIRFilterNodeFakerFactory = function (createInvalidAccessError, createInvalidStateError, createNotSupportedError) {
    return function (nativeAudioContext, _a) {
        var channelCount = _a.channelCount, channelCountMode = _a.channelCountMode, channelInterpretation = _a.channelInterpretation, feedback = _a.feedback, feedforward = _a.feedforward;
        var bufferSize = 256;
        var feedbackLength = feedback.length;
        var feedforwardLength = feedforward.length;
        var minLength = Math.min(feedbackLength, feedforwardLength);
        if (feedback.length === 0 || feedback.length > 20) {
            throw createNotSupportedError();
        }
        if (feedback[0] === 0) {
            throw createInvalidStateError();
        }
        if (feedforward.length === 0 || feedforward.length > 20) {
            throw createNotSupportedError();
        }
        if (feedforward[0] === 0) {
            throw createInvalidStateError();
        }
        if (feedback[0] !== 1) {
            for (var i = 0; i < feedforwardLength; i += 1) {
                feedforward[i] /= feedback[0];
            }
            for (var i = 1; i < feedbackLength; i += 1) {
                feedback[i] /= feedback[0];
            }
        }
        var scriptProcessorNode = nativeAudioContext.createScriptProcessor(bufferSize, channelCount, channelCount);
        scriptProcessorNode.channelCount = channelCount;
        scriptProcessorNode.channelCountMode = channelCountMode;
        scriptProcessorNode.channelInterpretation = channelInterpretation;
        var bufferLength = 32;
        var bufferIndexes = [];
        var xBuffers = [];
        var yBuffers = [];
        for (var i = 0; i < channelCount; i += 1) {
            bufferIndexes.push(0);
            var xBuffer = new Float32Array(bufferLength);
            var yBuffer = new Float32Array(bufferLength);
            // @todo Add a test which checks support for TypedArray.prototype.fill().
            xBuffer.fill(0);
            yBuffer.fill(0);
            xBuffers.push(xBuffer);
            yBuffers.push(yBuffer);
        }
        scriptProcessorNode.onaudioprocess = function (event) {
            var inputBuffer = event.inputBuffer;
            var outputBuffer = event.outputBuffer;
            var numberOfChannels = inputBuffer.numberOfChannels;
            for (var i = 0; i < numberOfChannels; i += 1) {
                var input = inputBuffer.getChannelData(i);
                var output = outputBuffer.getChannelData(i);
                bufferIndexes[i] = filterBuffer(feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);
            }
        };
        var nyquist = nativeAudioContext.sampleRate / 2;
        return {
            get bufferSize() {
                return bufferSize;
            },
            get channelCount() {
                return scriptProcessorNode.channelCount;
            },
            set channelCount(value) {
                scriptProcessorNode.channelCount = value;
            },
            get channelCountMode() {
                return scriptProcessorNode.channelCountMode;
            },
            set channelCountMode(value) {
                scriptProcessorNode.channelCountMode = value;
            },
            get channelInterpretation() {
                return scriptProcessorNode.channelInterpretation;
            },
            set channelInterpretation(value) {
                scriptProcessorNode.channelInterpretation = value;
            },
            get context() {
                return scriptProcessorNode.context;
            },
            get inputs() {
                return [scriptProcessorNode];
            },
            get numberOfInputs() {
                return scriptProcessorNode.numberOfInputs;
            },
            get numberOfOutputs() {
                return scriptProcessorNode.numberOfOutputs;
            },
            addEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // @todo Dissallow adding an audioprocess listener.
                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
            },
            connect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (args[2] === undefined) {
                    return scriptProcessorNode.connect.call(scriptProcessorNode, args[0], args[1]);
                }
                return scriptProcessorNode.connect.call(scriptProcessorNode, args[0], args[1], args[2]);
            },
            disconnect: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return scriptProcessorNode.disconnect.call(scriptProcessorNode, args[0], args[1], args[2]);
            },
            dispatchEvent: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return scriptProcessorNode.dispatchEvent(args[0]);
            },
            getFrequencyResponse: function (frequencyHz, magResponse, phaseResponse) {
                if ((frequencyHz.length !== magResponse.length) || (magResponse.length !== phaseResponse.length)) {
                    throw createInvalidAccessError();
                }
                var length = frequencyHz.length;
                for (var i = 0; i < length; i += 1) {
                    var omega = -Math.PI * (frequencyHz[i] / nyquist);
                    var z = [Math.cos(omega), Math.sin(omega)];
                    var numerator = evaluatePolynomial(feedforward, z);
                    var denominator = evaluatePolynomial(feedback, z);
                    var response = divide(numerator, denominator);
                    magResponse[i] = Math.sqrt((response[0] * response[0]) + (response[1] * response[1]));
                    phaseResponse[i] = Math.atan2(response[1], response[0]);
                }
            },
            removeEventListener: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
            }
        };
    };
};
//# sourceMappingURL=/build/es2015/factories/native-iir-filter-node-faker-factory.js.map