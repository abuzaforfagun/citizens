import * as tslib_1 from "tslib";
import { addAudioWorkletModule } from '../add-audio-worklet-module';
import { decodeAudioData } from '../decode-audio-data';
export var createBaseAudioContextConstructor = function (analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(BaseAudioContext, _super);
        function BaseAudioContext(nativeContext, numberOfChannels) {
            var _this = _super.call(this, nativeContext, numberOfChannels) || this;
            _this._audioWorklet = {
                addModule: function (moduleURL, options) { return addAudioWorkletModule(_this, moduleURL, options); }
            };
            _this._nativeContext = nativeContext;
            return _this;
        }
        Object.defineProperty(BaseAudioContext.prototype, "audioWorklet", {
            get: function () {
                return this._audioWorklet;
            },
            enumerable: true,
            configurable: true
        });
        BaseAudioContext.prototype.createAnalyser = function () {
            return new analyserNodeConstructor(this);
        };
        BaseAudioContext.prototype.createBiquadFilter = function () {
            return new biquadFilterNodeConstructor(this);
        };
        BaseAudioContext.prototype.createBuffer = function (numberOfChannels, length, sampleRate) {
            return new audioBufferConstructor({ length: length, numberOfChannels: numberOfChannels, sampleRate: sampleRate });
        };
        BaseAudioContext.prototype.createBufferSource = function () {
            return new audioBufferSourceNodeConstructor(this);
        };
        BaseAudioContext.prototype.createChannelMerger = function (numberOfInputs) {
            if (numberOfInputs === void 0) { numberOfInputs = 6; }
            return new channelMergerNodeConstructor(this, { numberOfInputs: numberOfInputs });
        };
        BaseAudioContext.prototype.createChannelSplitter = function (numberOfOutputs) {
            if (numberOfOutputs === void 0) { numberOfOutputs = 6; }
            return new channelSplitterNodeConstructor(this, { numberOfOutputs: numberOfOutputs });
        };
        BaseAudioContext.prototype.createConstantSource = function () {
            return new constantSourceNodeConstructor(this);
        };
        BaseAudioContext.prototype.createGain = function () {
            return new gainNodeConstructor(this);
        };
        BaseAudioContext.prototype.createIIRFilter = function (feedforward, feedback) {
            return new iIRFilterNodeConstructor(this, { feedback: feedback, feedforward: feedforward });
        };
        BaseAudioContext.prototype.createOscillator = function () {
            return new oscillatorNodeConstructor(this);
        };
        BaseAudioContext.prototype.decodeAudioData = function (audioData, successCallback, errorCallback) {
            return decodeAudioData(this._nativeContext, audioData)
                .then(function (audioBuffer) {
                if (typeof successCallback === 'function') {
                    successCallback(audioBuffer);
                }
                return audioBuffer;
            })
                .catch(function (err) {
                if (typeof errorCallback === 'function') {
                    errorCallback(err);
                }
                throw err;
            });
        };
        return BaseAudioContext;
    }(minimalBaseAudioContextConstructor));
};
//# sourceMappingURL=/build/es2015/factories/base-audio-context-constructor.js.map