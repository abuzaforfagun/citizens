import * as tslib_1 from "tslib";
import { deleteAudioGraph } from '../helpers/delete-audio-graph';
import { isValidLatencyHint } from '../helpers/is-valid-latency-hint';
export var createAudioContextConstructor = function (baseAudioContextConstructor, createInvalidStateError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioSourceNodeConstructor, nativeAudioContextConstructor) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(AudioContext, _super);
        function AudioContext(options) {
            if (options === void 0) { options = {}; }
            var _this = this;
            if (nativeAudioContextConstructor === null) {
                throw new Error(); // @todo
            }
            var nativeAudioContext = new nativeAudioContextConstructor(options);
            // Bug #51 Only Chrome and Opera throw an error if the given latencyHint is invalid.
            if (!isValidLatencyHint(options.latencyHint)) {
                throw new TypeError("The provided value '" + options.latencyHint + "' is not a valid enum value of type AudioContextLatencyCategory.");
            }
            _this = _super.call(this, nativeAudioContext, nativeAudioContext.destination.channelCount) || this;
            _this._state = null;
            _this._nativeAudioContext = nativeAudioContext;
            /*
             * Bug #34: Chrome and Opera pretend to be running right away, but fire an onstatechange event when the state actually changes
             * to 'running'.
             */
            if (nativeAudioContext.state === 'running') {
                _this._state = 'suspended';
                var revokeState_1 = function () {
                    if (_this._state === 'suspended') {
                        _this._state = null;
                    }
                    if (nativeAudioContext.removeEventListener) {
                        nativeAudioContext.removeEventListener('statechange', revokeState_1);
                    }
                };
                nativeAudioContext.addEventListener('statechange', revokeState_1);
            }
            return _this;
        }
        Object.defineProperty(AudioContext.prototype, "state", {
            get: function () {
                return (this._state !== null) ? this._state : this._nativeAudioContext.state;
            },
            enumerable: true,
            configurable: true
        });
        AudioContext.prototype.createMediaElementSource = function (mediaElement) {
            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement: mediaElement });
        };
        AudioContext.prototype.createMediaStreamSource = function (mediaStream) {
            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream: mediaStream });
        };
        AudioContext.prototype.close = function () {
            var _this = this;
            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.
            if (this.state === 'closed') {
                return this._nativeAudioContext
                    .close()
                    .then(function () {
                    throw createInvalidStateError();
                });
            }
            // Bug #34: If the state was set to suspended before it should be revoked now.
            if (this._state === 'suspended') {
                this._state = null;
            }
            return this._nativeAudioContext
                .close()
                .then(function () { return deleteAudioGraph(_this, _this._nativeAudioContext); });
        };
        AudioContext.prototype.resume = function () {
            return this._nativeAudioContext
                .resume()
                .catch(function (err) {
                // Bug #55: Chrome, Edge and Opera do throw an InvalidAccessError instead of an InvalidStateError.
                // Bug #56: Safari invokes the catch handler but without an error.
                if (err === undefined || err.code === 15) {
                    throw createInvalidStateError();
                }
                throw err;
            });
        };
        AudioContext.prototype.suspend = function () {
            return this._nativeAudioContext
                .suspend()
                .catch(function (err) {
                // Bug #56: Safari invokes the catch handler but without an error.
                if (err === undefined) {
                    throw createInvalidStateError();
                }
                throw err;
            });
        };
        return AudioContext;
    }(baseAudioContextConstructor));
};
//# sourceMappingURL=/build/es2015/factories/audio-context-constructor.js.map