import * as tslib_1 from "tslib";
import { cacheTestResult } from '../helpers/cache-test-result';
import { deleteAudioGraph } from '../helpers/delete-audio-graph';
import { testPromiseSupport } from '../support-testers/promise';
import { wrapAudioBufferCopyChannelMethods } from '../wrappers/audio-buffer-copy-channel-methods';
var DEFAULT_OPTIONS = {
    numberOfChannels: 1
};
var isSupportingPromises = function (nativeOfflineAudioContext) { return cacheTestResult(testPromiseSupport, function () { return testPromiseSupport(nativeOfflineAudioContext); }); };
export var createMinimalOfflineAudioContextConstructor = function (createInvalidStateError, minimalBaseAudioContextConstructor, nativeOfflineAudioContextConstructor, startRendering) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(MinimalOfflineAudioContext, _super);
        function MinimalOfflineAudioContext(options) {
            var _this = this;
            if (nativeOfflineAudioContextConstructor === null) {
                throw new Error(); // @todo
            }
            var _a = tslib_1.__assign({}, DEFAULT_OPTIONS, options), length = _a.length, numberOfChannels = _a.numberOfChannels, sampleRate = _a.sampleRate;
            var nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);
            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.
            if (!isSupportingPromises(nativeOfflineAudioContext)) {
                nativeOfflineAudioContext.addEventListener('statechange', (function () {
                    var i = 0;
                    var delayStateChangeEvent = function (event) {
                        if (_this._state === 'running') {
                            if (i > 0) {
                                nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);
                                event.stopImmediatePropagation();
                                _this._waitForThePromiseToSettle(event);
                            }
                            else {
                                i += 1;
                            }
                        }
                    };
                    return delayStateChangeEvent;
                })());
            }
            _this = _super.call(this, nativeOfflineAudioContext, numberOfChannels) || this;
            _this._length = length;
            _this._nativeOfflineAudioContext = nativeOfflineAudioContext;
            _this._state = null;
            return _this;
        }
        Object.defineProperty(MinimalOfflineAudioContext.prototype, "length", {
            get: function () {
                // Bug #17: Safari does not yet expose the length.
                if (this._nativeOfflineAudioContext.length === undefined) {
                    return this._length;
                }
                return this._nativeOfflineAudioContext.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MinimalOfflineAudioContext.prototype, "state", {
            get: function () {
                return (this._state === null) ? this._nativeOfflineAudioContext.state : this._state;
            },
            enumerable: true,
            configurable: true
        });
        MinimalOfflineAudioContext.prototype.startRendering = function () {
            var _this = this;
            /*
             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore
             * the state of the nativeOfflineAudioContext might no transition to running immediately.
             */
            if (this._state === 'running') {
                return Promise.reject(createInvalidStateError());
            }
            this._state = 'running';
            return startRendering(this.destination, this._nativeOfflineAudioContext)
                .then(function (audioBuffer) {
                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().
                if (typeof audioBuffer.copyFromChannel !== 'function') {
                    wrapAudioBufferCopyChannelMethods(audioBuffer);
                }
                _this._state = null;
                deleteAudioGraph(_this, _this._nativeOfflineAudioContext);
                return audioBuffer;
            })
                // @todo This could be written more elegantly when Promise.finally() becomes avalaible.
                .catch(function (err) {
                _this._state = null;
                deleteAudioGraph(_this, _this._nativeOfflineAudioContext);
                throw err;
            });
        };
        MinimalOfflineAudioContext.prototype._waitForThePromiseToSettle = function (event) {
            var _this = this;
            if (this._state === null) {
                this._nativeOfflineAudioContext.dispatchEvent(event);
            }
            else {
                setTimeout(function () { return _this._waitForThePromiseToSettle(event); });
            }
        };
        return MinimalOfflineAudioContext;
    }(minimalBaseAudioContextConstructor));
};
//# sourceMappingURL=/build/es2015/factories/minimal-offline-audio-context-constructor.js.map