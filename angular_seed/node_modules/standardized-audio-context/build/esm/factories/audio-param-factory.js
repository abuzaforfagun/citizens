import { AUDIO_PARAM_STORE } from '../globals';
import { getAudioGraph } from '../helpers/get-audio-graph';
var addAudioParam = function (context, audioParam, audioParamRenderer) {
    var audioGraphOfContext = getAudioGraph(context);
    audioGraphOfContext.params.set(audioParam, { inputs: new Set(), renderer: audioParamRenderer });
};
export var createAudioParamFactory = function (createAudioParamRenderer) {
    return function (context, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue, minValue) {
        if (maxValue === void 0) { maxValue = null; }
        if (minValue === void 0) { minValue = null; }
        var audioParamRenderer = (isAudioParamOfOfflineAudioContext) ? createAudioParamRenderer() : null;
        var audioParam = {
            get defaultValue() {
                return nativeAudioParam.defaultValue;
            },
            get maxValue() {
                return (maxValue === null) ? nativeAudioParam.maxValue : maxValue;
            },
            get minValue() {
                return (minValue === null) ? nativeAudioParam.minValue : minValue;
            },
            get value() {
                return nativeAudioParam.value;
            },
            set value(value) {
                nativeAudioParam.value = value;
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ startTime: context.currentTime, type: 'setValue', value: value });
                }
            },
            cancelScheduledValues: function (cancelTime) {
                nativeAudioParam.cancelScheduledValues(cancelTime);
                // @todo
                return audioParam;
            },
            exponentialRampToValueAtTime: function (value, endTime) {
                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ endTime: endTime, type: 'exponentialRampToValue', value: value });
                }
                return audioParam;
            },
            linearRampToValueAtTime: function (value, endTime) {
                nativeAudioParam.linearRampToValueAtTime(value, endTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ endTime: endTime, type: 'linearRampToValue', value: value });
                }
                return audioParam;
            },
            setTargetAtTime: function (target, startTime, timeConstant) {
                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ startTime: startTime, target: target, timeConstant: timeConstant, type: 'setTarget' });
                }
                return audioParam;
            },
            setValueAtTime: function (value, startTime) {
                nativeAudioParam.setValueAtTime(value, startTime);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ startTime: startTime, type: 'setValue', value: value });
                }
                return audioParam;
            },
            setValueCurveAtTime: function (values, startTime, duration) {
                // @todo TypeScript is expecting values to be an array of numbers.
                nativeAudioParam.setValueCurveAtTime(values, startTime, duration);
                if (audioParamRenderer !== null) {
                    audioParamRenderer.record({ duration: duration, startTime: startTime, type: 'setValueCurve', values: values });
                }
                return audioParam;
            }
        };
        AUDIO_PARAM_STORE.set(audioParam, nativeAudioParam);
        addAudioParam(context, audioParam, audioParamRenderer);
        return audioParam;
    };
};
//# sourceMappingURL=/build/es2015/factories/audio-param-factory.js.map